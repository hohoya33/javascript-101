<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">
		<title>JavaScript - 101</title>
		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/league.css" id="theme">
		<!-- <link rel="stylesheet" href="css/theme/ember.css" id="theme"> -->
		<!-- Code syntax highlighting -->
		<!-- <link rel="stylesheet" href="lib/css/monokai_sublime.css"> -->
		<!-- <link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/atom-one-dark.css"> -->
		<!-- <link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/monokai-sublime.css"> -->
		<!--<link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/monokai.css">       -->
		<link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/atom-one-dark.css">
		<link rel="stylesheet" href="https://code.cdn.mozilla.net/fonts/fira.css">
		<link rel='stylesheet' href='lib/font/devicons/devicons.css'>
		<style type="text/css">
		.reveal{font-size:24px}
		.txl{text-align:left;display:inline-block}
		.devicons-javascript{color:#f5de19}
		.devicons-html5{color:#e44f26}
		.devicons-css3{color:#1572b6}
		.devicons-npm{color:#a23332}
		.devicons-sass{color:#cd6799}
		</style>
		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>
		<div class="reveal">
			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<div><img src="img/js_logo.png " alt="" style="width:18%;"></div>
					<h1 style="margin-bottom:60px;font-size:50px;letter-spacing:normal">JavaScript - 101</h1>
					<p>2018. 03. 23</p>
					<p>IT 개발2팀 UI파트 - 김재호</p>
				</section>

				<section>
					<h2>The Agenda</h2>
					<ul>
						<li>JavaScript 소개</li>
						<li>JavaScript 시작</li>
						<li>변수 (Variable)</li>
						<li>배열 (Array)</li>
						<li>객체 (Object)</li>
						<li>함수 (Function)</li>
						<li>유효범위 (Scope)</li>
						<li>객체지향 프로그래밍 (OOP)</li>
						<li>jQuery</li>
					</ul>
				</section>

				<section>
					<section>
						<h2>JavaScript 소개</h2>
					</section>
					<section>
						<h2>JavaScript?</h2>
						<!-- <div><img src="img/html-css-javascript.png " alt="" style="width:30%;"></div> -->
						<div><img src="img/java_vs_js.png " alt="" style="width:30%"></div>
						<ul style="margin-top:20px">
							<li>HTML과 CSS는 정적인 언어</li>
							<li>JavaScript는 HTML과 CSS로 만들어진 웹페이지를 동적으로 변경해주는 언어</li>
							<li>HTML, CSS 기본적인 선행학습 필요</li>
							<li>작성한 코드를 브라우저에서 바로 실행 가능</li>
						</ul>
					</section>
					<section>
						<h2>JavaScript의 역할</h2>
						<ul>
							<li>HTML 엘리먼트 추가/삭제 및 CSS 스타일 변경</li>
							<li>폼 유효성 검증</li>
							<li>사용자와의 상호작용 (마우스, 키보드, 터치)</li>
							<li>웹 브라우저 쿠키 설정/조회</li>
							<li>AJAX 이용한 웹 서버와 통신</li>
						</ul>
					</section>

					<!--
					<section>
						<h2>JavaScript의 문제점</h2>
                        <ul>
                            <li>글로벌(전역) 스코프가 쉽게 오염</li>
                            <li>동일한 이름을 가진 변수 사용</li>
                            <li>올바른 의존성 순서</li>
                            <li>웹페이지가 커질수록 script 태그 수 의 증가</li>
                        </ul>
					</section>

					<section>
						<h2>새로운 자바스크립트 (ECMAScript 6)</h2>
						<div style="display:flex;align-items:center;justify-content:center;margin:50px 0">
							<div style="max-width:50%;"><img src="img/es6.png" alt="" style="width:30%"></div>
							<div style="max-width:50%;"><img src="img/babel.png" alt="" style="width:50%"></div>
						</div>
						<ul>
							<li>표준화된 Javascript 버전 (표준의 6번째 에디션, ECMAScript2015)</li>
							<li>let, const, Arrow Functions, Classes, Module system, Promise...</li>
							<li>IE를 제외한 대부분의 모던 브라우저는 지원 <a href="http://kangax.github.io/compat-table/es6/" target="_blank">(ES6 호환성)</a></li>
							<li>ES6코드를 ES5코드로 변환 Transpiler 사용 <a href="http://babeljs.io/" target="_blank">(Babel)</a></li>
						</ul>
					</section>
					 -->


					<section>
						<h2>과거 JavaScript는?</h2>
						<p>초창기 웹페이지의 보조적인 기능을 수행하기 위한 용도로 사용</p>
						<div><img src="img/naver_daum.png" alt="" style="width:65%"></div>
						<!-- <div style="display:flex;align-items:center;justify-content:center;margin:50px 0">
							<div style="max-width:50%;"><img src="img/netscape.png" alt="" style="width:50%"></div>
							<div style="max-width:50%;"><img src="img/ie.png" alt="" style="width:48%"></div>
							<div style="max-width:50%;"><img src="img/naver_daum.png" alt=""></div>
						</div> -->
						<ul>
							<li>1995년 브렌던 아이크(Brendan Eich) 넷스케이프 지원<br>모카 -> 라이브스크립트 -> 자바스크립트</li>
							<li>국제 표준화 단체인 ECMA International에서 JavaScript 표준화 진행</li>
							<li>크로스 브라우징, 보안 취약점 문제</li>
							<li>전문적이지 못한 인식 (Copy & Paste)</li>
						</ul>
					</section>

					<section>
						<h2>JavaScript 환경 변화</h2>
						<ul>
							<li>데이터의 유형이 텍스트 -> 이미지 -> 미디어로 진화</li>
							<li>과거에 서버에서 담당하던 역할들이 상당 부분 프론트 이동</li>
						</ul>

						<!-- 웹이 나오게된 배경 중 하나가 문서 표현 및 전달하기 위한 기술이 중심이었다.
						이후 웹은 쇼핑이나 뱅킹 등 기존에 오프라인으로만 가능하던 여러 분야에서 사용되기 시작하면서 다양한 분야에서 폭넓게 활용되기 시작했다. -->

						<div style="display:flex;align-items:center;justify-content:center;margin:50px 0">
							<div style="max-width:50%;margin:0 5px"><span style="display:flex;align-items:center;justify-content:center;width:150px;height:150px;border-radius:100%;background:#fff"><img src="img/ajax.png" alt="" style="width:80%"></span></div>
							<div style="max-width:50%;margin:0 5px"><span style="display:flex;align-items:center;justify-content:center;width:150px;height:150px;border-radius:100%;background:#fff"><img src="img/jquery.png" alt=""></span></div>
							<div style="max-width:50%;margin:0 5px"><span style="display:flex;align-items:center;justify-content:center;width:150px;height:150px;border-radius:100%;background:#fff"><img src="img/html5.png" alt="" style="width:70%"></span></div>
							<div style="max-width:50%;margin:0 5px"><span style="display:flex;align-items:center;justify-content:center;width:150px;height:150px;border-radius:100%;background:#fff"><img src="img/nodejs.png" alt="" style="width:80%"></span></div>
							<div style="max-width:50%;margin:0 5px"><span style="display:flex;align-items:center;justify-content:center;width:150px;height:150px;border-radius:100%;background:#fff"><img src="img/es6.png" alt="" style="width:65%"></span></div>
						</div>
						<ul>
							<li>Ajax - 전체 페이지를 다시 렌더링하지 않고 변경되는 부분만 갱신</li>
							<li>jQuery - 보다 쉽게 DOM을 핸들링</li>
							<li>HTML5 - 마크업, JavaScript API를 강화</li>
							<li>NodeJS - 서버 개발 가능, 더 많은 개발자들이 자바스크립트 사용</li>
							<li>ECMAScript2015 (ES6) - 언어로서의 완성도가 높아짐</li>
						</ul>
					</section>


					<section>
						<h2>현재 자바스크립트는?</h2>
						<p>브라우저에서만 사용하는 용도를 벗어나 다양한 환경에서 폭넓게 활용</p>

						<div style="margin:40px 0"><img src="img/js_all.png" alt=""></div>
						<ul>
							<li>MeanStack (Full Stack Javascript Framework)</li>
							<li>클라이언트 / 서버 / 데이터베이스 모두 자바스크립트 기반 (JSON 형태로 통신)</li>
							<li>모바일 앱(iOS & Android), 데스크탑 앱</li>
						</ul>
					</section>


					<section>
						<h2>SPA (Single Page Application)</h2>
						<div><img src="img/react_angular_vue.png" alt="" style="width:58%"></div>
						<ul>
							<li>PC -> 모바일 사용자의 증가 (트래픽 감소와 속도, 사용성, 반응성 이슈)</li>
							<li>프론트엔드 프레임워크의 강화 (React, Angular, Vue)</li>
							<li>필요한 모든 정적 리소스를 최초에 한번 다운로드</li>
							<li>페이지 이동없이 고속으로 화면 전환</li>
							<li>네이티브 앱과 유사한 사용자 경험 제공</li>
						</ul>
					</section>

					<section>
						<h2>PWA (Progressive Web Apps)</h2>
						<p>최적화된 웹 성능에 모바일의 Native 기능을 결합한 최신 웹 앱</p>
						<div><img src="img/unnamed.gif" alt=""></div>
						<ul>
							<li>모바일 앱의 단점 (개발, 빌드, 배포, 검색 다운로드, 설치)</li>
							<li>홈 화면 아이콘 추가, 오프라인 서비스, 푸시 알림 등 웹에서도 가능하게 하는 기술<br>(Service Worker)</li>
						</ul>
					</section>
				</section>



				<section>
					<section>
						<h2>JavaScript 시작</h2>
					</section>

					<section>
						<h2>코드 작성 준비</h2>
						<ul>
							<li>아래 코드를 HTML head, body 태그 안에 작성</li>
							<li>script 태그의 src 속성을 사용하여 외부 js 파일 연결</li>
						</ul>
						<pre><em class="file_name"><i class="devicons devicons-html5"></i>&nbsp;index.html</em><code class="html">
		&lt;!-- internal --&gt;
		&lt;script type="text/javascript"&gt;
			//코드 작성

			//한줄주석
			/* 여러줄 주석 */
		&lt;/script&gt;

		&lt;!-- external --&gt;
		&lt;script type="text/javascript" scr="js/ui/ui-base.js"&gt;&lt;/script&gt;
                        </code></pre>
					</section>

					<section>
						<h2>script 태그 위치</h2>
						<pre><em class="file_name"><i class="devicons devicons-html5"></i>&nbsp;index.html</em><code class="html">
	&lt;!DOCTYPE html&gt;
	&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;HTML Page&lt;/title&gt;
		//Bad
		&lt;script scr="js/lib/jquery-1.9.1.min.js"&gt;&lt;/script&gt;
		&lt;script scr="js/ui/ui-base.js"&gt;&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
		...
		//Good
		//body 요소 안, 맨 마지막 위치
		&lt;script scr="js/lib/jquery-1.9.1.min.js"&gt;&lt;/script&gt;
		&lt;script scr="js/ui/ui-base.js"&gt;&lt;/script&gt;
	&lt;/body&gt;
	&lt;/html&gt;
                        </code></pre>
					</section>

					<section>
						<h2>script 태그 속성</h2>
						<div>
							<p style="padding-left:145px;text-align:left;margin:0">&lt;script src="script.js"&gt;</p>
							<img style="margin-top:0" src="img/Normal-Execution.png " alt="">
						</div>
						<div>
							<p style="padding-left:145px;text-align:left;margin:0">&lt;script async src="script.js"&gt;</p>
							<img style="margin-top:0" src="img/Async-Execution.png " alt="">
						</div>
						<div>
							<p style="padding-left:145px;text-align:left;margin:0">&lt;script defer src="script.js"&gt;</p>
							<img style="margin-top:0" src="img/Defer-Execution.png " alt="">
						</div>
					</section>
				</section>



				<section>
					<section>
						<h2>변수 (Variable)</h2>
					</section>

					<section>
						<h2>변수 선언</h2>
						<ul>
							<li>숫자로 시작 할 수 없음</li>
							<li>대소문자 구별</li>
							<li>이미 정의된 예약어 사용 안됨 (var, function, new, typeof..)</li>
						</ul>

						<pre><code class="js">
	var number;
	var str;

	//한번에 선언 (콤마를 이용해 구분)
	var number, str;

	//숫자시작 X
	var 1st = 10; //SyntaxError

	//대소문자 구분, 완전히 다른변수
	var value = 25;
	var Value = 26;

	//예약어 X
	var function; //SyntaxError
                        </code></pre>
					</section>

					<section>
						<h2>변수의 중복 선언</h2>
						<p>변수의 중복 선언은 문법적으로 허용, 하지만 사용하지 않는 것이 좋음</p>
						<pre><code class="js">
	var x = 1;
	console.log(x); //1

	//중복 선언
	var x = 100;
	console.log(x); //100
                        </code></pre>
					</section>

					<section>
						<h2>변수 선언 시 var 키워드 생략 허용</h2>
						<p>의도하지 않게 변수를 전역화할 수 있으므로 사용하지 않는 것이 좋음</p>
						<pre><code class="js">
	x = 1;
	console.log(x); //1
                        </code></pre>
					</section>


					<section>
						<h2>분산된 var 선언의 문제점</h2>
						<pre><code class="js">
	//예기치 않은 결과
    function myFunction() {
        console.log(foo); //① undefined
        //Why no ReferenceError?

        if(true) {
            var foo = 123;
            console.log(foo); //② 123
        }
    }

    myFunction();
                        </code></pre>
					</section>

					<section>
						<h2>변수 호이스팅 (Hoisting)</h2>
						<p>코드를 해석하기 전 var 선언 범위를 상단으로 이동 합니다.</p>
						<ul>
							<li>모든 변수 선언은 각 함수(스코프)의 가장 최상위로 끌어 올려짐</li>
							<li>첫 줄 이후 선언된 변수들은 호이스팅으로 인해 선언한 곳 이전부터 존재</li>
						</ul>

						<pre><code class="js">
    function myFunction() {
    	//var foo; -> 변수는 호이스트 되었습니다.
        console.log(foo); //① undefined

        if(true) {
            var foo = 123;
            console.log(foo); //② 123
        }
    }

    myFunction();
                        </code></pre>
					</section>



					<section>
						<h2>자료형 (Data type)</h2>
						<ul>
							<li>기본 자료형 - Boolean, null, undefined, Number, String, Symbol</li>
							<li>객체형 - Object (Function, Array, Date, RegExp)</li>
							<li>동적 타입 언어, 느슨한 타입 언어</li>
							<li>변수 선언 시 타입 정의 없음</li>
							<li>값을 할당할 때 데이터 형이 결정되는 것이 특징</li>
							<li>같은 변수에 여러 데이터 타입의 값을 대입 가능 (가능한 변경하지 않는다)</li>
						</ul>
					</section>

					<section>
						<pre><code class="js">
	//값을 할당하지 않은 변수는 기본적으로 undefined
	//자료형이 결정되지 않은 상태
	var foo;
	console.log(typeof foo); //undefined

	//null은 개발자가 의도적으로 빈 값을 할당 (비어있는 변수)
	var foo = 'Kim';
	foo = null;  //참조 정보가 제거됨

	foo = 3;
	console.log(typeof foo);  //number

	foo = 'Hi';
	console.log(typeof foo);  //string

	foo = true;
	console.log(typeof foo);  //boolean

	숫자를 다루다 보면 숫자 범위를 초과하거나 오류로 NaN
	NaN (Not a Number) 숫자가 아니라는 뜻
                        </code></pre>
					</section>


					<section>
						<h2>네이밍 규칙</h2>
						<p>변수의 데이터 타입과 용도에 따라 접두사와 함께 붙여 사용 (헝가리안 표기법)</p>

						<table>
							<tr>
								<th>접두사</th>
								<th>데이터 타입</th>
								<th>예시</th>
							</tr>
							<tr>
								<td>a</td>
								<td>Array</td>
								<td>aUsers</td>
							</tr>
							<tr>
								<td>s</td>
								<td>String</td>
								<td>sCompanyName</td>
							</tr>
							<tr>
								<td>n</td>
								<td>Number</td>
								<td>nTotalCount</td>
							</tr>
							<tr>
								<td>b</td>
								<td>Boolean</td>
								<td>bFlag, bActivation</td>
							</tr>
							<tr>
								<td>o</td>
								<td>Object</td>
								<td>oController</td>
							</tr>
							<tr>
								<td>ht</td>
								<td>Hash Table</td>
								<td>htUserInfo, htColorCode</td>
							</tr>
							<tr>
								<td>d</td>
								<td>Date</td>
								<td>dToday, dCurrentTime</td>
							</tr>
							<tr>
								<td>el</td>
								<td>Html Element</td>
								<td>elTableList</td>
							</tr>
							<tr>
								<td>rx</td>
								<td>Regular Expression</td>
								<td>rxEmailFormat</td>
							</tr>
						</table>
					</section>


					<section>
						<h2>'==' vs '==='의 차이</h2>
						<ul>
							<li>동등 연산자 (==, !=) 값이 같으면 true (강제 형 변환 후 비교)</li>
							<li>일치 연산자 (===, !==) 값이 같고 데이터 타입도 같아야만 true</li>
							<li>==보다는 ===를 쓰는 것을 권장</li>
						</ul>

						<pre><code class="js">
	0 == ''     //true
	0 == '0'     //true
	1 == true     //true
	null == undefined    //true
                        </code></pre>
                        <pre><code class="js">
	0 === ''     //false
	0 === false    //false
	1 === true     //false
	null === undefined     //false
                        </code></pre>

					</section>

				</section>



				<section>
					<section>
						<h2>배열 (Array)</h2>
					</section>

					<section>
						<h2>배열 생성</h2>
						<p>여러 개의 데이터 값을 하나의 변수에 할당할 때 사용</p>
						<pre><code class="js">
	var arr1 = []; //배열 리터럴 사용
	var arr2 = new Array();
                        </code></pre>
					</section>

					<section>
						<h2>배열 요소 추가</h2>
						 <ul>
						 	<li>필요한 index 위치에 값 할당 (순서에 맞게 값을 할당할 필요는 없음)</li>
						 	<li>값이 할당되지 않은 index 요소의 값은 empty</li>
						 	<li>배열의 길이(length)는 최종 index 기준으로 산정</li>
						 </ul>

						<pre><code class="js">
	//배열 요소에 index로 값 할당
	var fruits = [];
	fruits[0] = '사과';
	fruits[1] = '배';
	fruits[2] = '바나나';

	//배열을 생성과 동시에 요소에 값 할당
	var fruits = ['사과', '배', '바나나'];

	var arr = [];
	arr[0] = 'one';
	arr[3] = 'three';
	arr[7] = 'seven';
	console.log(arr); //["one", empty × 2, "three", empty × 2, "seven"]
                        </code></pre>
					</section>

					<section>
						<h2>배열 요소 열거</h2>
						<p>배열 뒤 [ ]안에 index를 넣어 요소에 접근</p>
						<pre><code class="js">
	var fruits = ["사과", "배", "바나나"];
	console.log(fruits[0]); //사과
	console.log(fruits[1]); //배
	console.log(fruits[2]); //바나나

	//요소 갯수 (배열 길이)
	console.log(fruits.length); //3

	//for문 사용
	for (var i = 0; i < fruits.length; i++) {
		console.log(i, fruits[i]); //0 사과, 1 배, 2 바나나
	}
                        </code></pre>
					</section>

					<section>
						<h2>배열 메서드 (Array method)</h2>
						<ul>
							<li>join– 문자열로 리턴 (원본 변경 X)</li>
							<li>reverse– 거꾸로 변경</li>
							<li>sort– 배열 정렬</li>
							<li>concat– 배열 이어 붙임 (원본 변경 X)</li>
							<li>slice– 부분 배열 반환 (원본 변경 X)</li>
							<li>splice– 삭제/추가</li>
							<li>push, pop– 맨뒤 추가/삭제</li>
							<li>shift, unshift– 맨앞 추가/삭제</li>
						</ul>
					</section>
				</section>


				<section>
					<section>
						<h2>객체 (Object)</h2>
					</section>


					<section>
						<h2>자동차 객체</h2>
						<ul>
							<li>모든 자동차는 같은 속성을 가지고 있지만 그 값은 각각 다르고, 다양한 기능을 수행</li>
							<li>현실세계의 객체를 프로그래밍적으로 접근하여 접목시킨 것을 객체라고 표현</li>
						</ul>

						<!-- <ul>
							<li>속성(Property) - 이름, 모델, 무게, 색상</li>
							<li>메서드(Method) - 출발하다(), 정지하다(), 속력을 올리다(), 속력을 줄이다()</li>
						</ul>
						자바스크립트에는 TV 를 켜다와 같은 여러 다양한 기능들이 있는데 이러한 기능들을 메서드(Method)
						 -->

						<table style="margin-top:50px">
							<tr>
								<th style="width:30%">Object</th>
								<th style="width:35%">Properties</th>
								<th style="width:35%">Methods</th>
							</tr>
							<tr>
								<td rowspan="4" style="vertical-align:middle;text-align:left;border-bottom-width:0"><img src="img/genesis.png" alt=""></td>
								<td>car.name = 제네시스</td>
								<td>car.start()</td>
							</tr>
							<tr>
								<td>car.model = G70</td>
								<td>car.stop()</td>
							</tr>
							<tr>
								<td>car.weight = 1,695kg</td>
								<td>car.speedUp()</td>
							</tr>
							<tr>
								<td>car.color = white</td>
								<td>car.slowDown()</td>
							</tr>
						</table>
					</section>


					<section>
						<h2>객체 생성</h2>
						<ul>
							<li>자바스크립트는 객체 기반 언어</li>
							<li>기본자료형을 제외한 나머지 함수, 배열, 정규표현식 등 모두 객체</li>
						</ul>

						<pre><code class="js">
	var obj1 = {}; //객체 리터럴 사용
	var obj2 = new Object();
                        </code></pre>
					</section>

					<section>
						<h2>객체 속성 (Property)</h2>
						<ul>
							<li>객체는 Key(속성명), Value(값)로 구성</li>
							<li>빈 객체를 생성하여 변수와 함수를 그 안에 추가</li>
							<li>이때 선언된 변수를 '프로퍼티', 함수는 '메서드'</li>
						</ul>
						<pre><code class="js">
	//객체 생성 후 프로퍼티를 추가
	var car = {};
	car.name = '제네시스';
	car.model = 'G70';
	car.weight = '1,695kg';
	car.color = 'white';

	//객체 생성과 동시에 프로퍼티를 추가
	var car = {
		name: '제네시스',
		model: 'G70',
		weight: '1,695kg',
		color: 'white'
	};
	console.log(car.name); //제네시스
                        </code></pre>
					</section>

					<section>
						<h2>객체 메서드 (Method)</h2>
						<p>메서드 내부의 this는 해당 메소드를 호출한 객체에 바인딩</p>
						<!-- 이러한 개발 패턴은 자바스크립트 개발에서 자주 사용 -->
						<pre><code class="js">
	var car = {
		name: '제네시스',
		model: 'G70',
		weight: '1,695kg',
		getName: function() {
			return this.name;
		}
	};

	var car2 = {
		name: 'BMW'
	};

	car2.getName = car.getName;

	car.getName(); //this는 car, this.name -> 제네시스
	car2.getName(); //this는 car2, this.name -> BMW
                        </code></pre>
					</section>

				</section>



				<section>
					<section>
						<h2>함수 (Function)</h2>
					</section>

					<section>
						<h2>함수선언식 (Function declaration)</h2>
						<p>주로 반복적으로 사용되는 구문을 미리 작성해 두고 필요할 때 호출</p>
						<!-- 반복적인 작업을 줄여 주므로 개발 효율과 코드의 양을 줄여 주는데 많은 도움이 됩니다. -->
						<pre><code class="js">
	function 함수이름(parameter1, parameter2,...) {
	    //code
	}

	function total(a, b) {
		return a + b;
	}

	//함수 호출
	total(10, 20); //30
                        </code></pre>
					</section>

					<section>
						<h2>함수표현식 (Function expression)</h2>
						<p>함수표현식으로 정의한 함수는 함수명 생략 가능</p>
						<pre><code class="js">
	// 익명 함수표현식
	var total = function(a, b) {
	    return a + b;
	};

	total(10, 20); //30
                        </code></pre>
					</section>

					<section>
						<h2>함수 호이스팅 (Function hoisting)</h2>
						<ul>
							<li>함수선언식 - 함수 선언의 위치와 상관없이 코드 내 어느 곳에서든지 호출 가능</li>
							<li>함수표현식 - 호이스팅된 변수는 undefined로 초기화</li>
							<li>함수선언식은 함수호출 전 반드시 선언하여야 한다는 규칙을 무시<br>코드의 구조를 엉성하게 만들 수 있어 함수표현식 사용권고</li>
						</ul>
						<!--
						함수선언식으로 정의된 함수는 자바스크립트 엔진이 스크립트가 로딩되는 시점에 바로 초기화하고 이를 VO(variable object)에 저장한다. 즉, 함수 선언, 초기화, 할당이 한번에 이루어진다. 그렇기 때문에 함수 선언의 위치와는 상관없이 소스 내 어느 곳에서든지 호출이 가능하다.

                        함수표현식은 함수선언식과는 달리 스크립트 로딩 시점에 변수 객체(VO)에 함수를 할당하지 않고 runtime에 해석되고 실행되므로 이 두가지를 구분하는 것은 중요하다.
 						-->
						<pre><code class="js">
	//함수선언에서의 호이스팅
	foo(); //hello
	function foo() {
	    console.log('hello');
	}

	//함수표현에서의 호이스팅
	foo(); //TypeError: foo is not a function
	var foo = function() {
	    console.log('hello');
	};
                        </code></pre>

					</section>




					<section>
						<h2>즉시실행함수 (IIFE)</h2>
						<ul>
							<li>함수의 정의와 동시에 실행되는 함수</li>
							<li>최초 한번만 호출되며 다시 호출할 수 없음</li>
							<li>이러한 특징을 이용하여 초기화 처리에 사용, 글로벌 영역 오염방지</li>
						</ul>

						<pre><code class="js">
	// 익명 즉시실행함수(immediately-invoked function expression)
	(function () {
		//code
	}());
                        </code></pre>
					</section>

					<section>
						<h2>콜백 함수 (Callback function)</h2>
						<p>어떤 이벤트가 발생한 후 수행될 함수 (이벤트 핸들러 처리)</p>

						<pre><code class="html">
	&lt;button id="myButton">Click me&lt;/button&gt;

	&lt;script&gt;
		var button = document.getElementById('myButton');

		button.addEventListener('click', function() {
			console.log('button clicked!');
		});
	&lt;/script&gt;
                        </code></pre>
					</section>


				</section>


				<section>
					<section>
						<h2>유효범위 (Scope)</h2>
					</section>

					<section>
						<h2>자바스크립트의 유효범위</h2>
						<ul>
							<li>전역 (Global scope) - 코드 어디에서든지 참조</li>
							<li>지역 (Local scope or Function-level scope) - 정의된 함수 내에서만 참조</li>
						</ul>
					</section>

					<section>
						<h2>전역변수 (Global scope)</h2>
						<p>자바스크립트는 특별한 시작점이 없음</p>

						<!--
						글로벌 영역에 변수를 선언하면 이 변수는 어느 곳에서든지 참조할 수 있는 global scope를 갖는 전역 변수가 된다.
						하지만 자바스크립트는 다른 언어와는 달리 특별한 시작점이 없으며 코드가 나타나는 즉시 해석되고 실행된다.
						 따라서 글로벌 영역에 변수를 선언하기 쉬우며 이것는 전역 변수를 남발하게 하는 문제를 야기시킨다.

						전역 변수의 사용은 변수명의 중복 등 여러 문제를 발생시키므로 가급적 사용을 억제하여야 한다. -->
						<pre><code class="js">
	//Global scope
	var global = 'global'; //전역변수

	function foo() {
		console.log(global);
	}
	foo(); //global
                        </code></pre>
					</section>

					<section>
						<h2>Non Block-level scope</h2>
						<p>var 선언된 변수는 Block-level scope를 사용하지 않으므로 x는 전역 변수</p>

						<!-- 변수 x는 코드 블럭 내에서 선언되었다.
						하지만 자바스크립트는 block-level scope를 사용하지 않으므로
						function 밖에서 선언된 변수는 코드 블럭 내에서 선언되었다할지라도 모두 global scope을 갖게된다.
						따라서 변수 x는 전역 변수이다. -->

						<pre><code class="js">
	if (true) {
		var x = 5; //전역변수
	}
	console.log(x); //5
                        </code></pre>
					</section>

					<section>
						<h2>지역변수 (Function-level scope)</h2>
						<ul>
							<li>함수 내에 선언된 변수, 매개변수(parameter)는 함수 외부에서 유효하지 않음</li>
							<li>해당 함수 내에 정의된 중첩, 자식 함수를 비롯해 함수 내부에서만 사용 가능</li>
						</ul>
						<pre><code class="js">
	function foo() {
		//Local scope
		var local = 'local'; //지역변수
		console.log(local); //local
	}
	foo();
	console.log(local); //ReferenceError: local is not defined
                        </code></pre>
					</section>


					<section>
						<h2>전역변수, 지역변수 동일한 이름 사용 시</h2>
						<ul>
							<li>변수명이 중복된 경우, 지역변수를 우선하여 참조 (각기 다른 변수객체가 생성)</li>
							<li>혼란을 막기 위해 동일한 변수 네이밍은 가급적 사용하지 않는 것이 좋음</li>
						</ul>
						<pre><code class="js">
	var global = 'global'; //전역변수

	function foo() {
		var global = 'local'; //지역변수
	  	console.log(global); //local
	}
	foo();
	console.log(global); //global
                        </code></pre>
					</section>


					<section>
						<h2>스코프 체인 (Scope chain)</h2>
						<p>변수를 찾을 때 스코프의 계층 구조에 기반한 스코프 체인을 거슬러 올라가며 추적</p>

						<!--
						func2 함수에서 참조한 변수는 지역 스코프에 없을 경우 스코프 체인에서 변수를 검색하게 되며
						스코프 체인을 검색할 때는 가장 처음 발견한 값을 반환

						스코프 체인을 통해 해당 변수들을 찾게 되고
						number3, number2, number1의 순서로 접근하여 값을 func2 함수로 전달하여 연산을 수행

						func2 함수에서 number1, number2, number3 변수를 찾게 되고,
						이 값이 없으면 부모 함수인 func1 에서 검색을 하게 되고 여기에도 없으면
						func1 부모 함수가 없기 때문에 전역 스코프에서 값을 찾게 됩니다.
						전역 스코프에서 변수를 발견하게 되면 이 값을 func2로 전달하게 되는 것을 자바스크립트 스코프 체인의 핵심 역할
 						-->

						<pre><code class="js">
	//각각의 변수들은 각기 다른 스코프에서 선언
	//스코프 체인을 검색할 때 가장 처음 발견한 값을 반환
	var number1 = 1;

	function func1(){
		var number2 = 2;

		function func2(){
			var number3 = 3;
			console.log(number1 + number2 + number3); //6
		}
		func2();
	}
	func1();
                        </code></pre>
					</section>

					<section>
						<h2>클로저 (Closure)</h2>
						<ul>
							<li>내부함수는 외부함수의 지역변수에 접근 가능</li>
							<li>add()함수가 종료되더라도 내부변수 스코프 객체는 그대로 유지되는 클로저의 속성을 이용</li>
							<li>클로저를 이용해 비공개 멤버(private) 생성</li>
						</ul>


						<!--
						add()를 호출해서 생성된 객체를 foo에 할당
						foo() 호출될 때 이전에 증가된 값이 유지되어 두 번째 호출의 시작값이 됩니다.
						add()함수 호출이 종료되더라도 내부변수 스코프 객체는 그대로 유지되는 클로저의 속성을 그대로 이용
						다시 한번 add()를 호출해서 새로운 인스턴스를 bar에 할당한 후 호출해서 결과를 보면
						내부 변수 counter가 새롭게 초기화됐다는 사실로 앞의 클로저와는 다른 닫힌 환경을 가진 새로운 인스턴스가 생성됐음을 알 수 있습니다.

						클로저를 호출하면 단순히 객체가 반환되는 것이 아닙니다.
						객체와 함께 그것과 연결된 닫힌 공간이 함께 반환되는 것입니다.
						그리고 그 닫힌 공간에 내부 변수가 존재합니다.

						클로저(closure)는 내부함수와 밀접한 관계를 가지고 있는 주제다.
						이제 비공개 멤버와 공개 멤버를 가진 객체를 구현하는 패턴화된 기법
						자바스크립트에서도 일반 객체지향 언어에서의 객체와 유사한 구조의 객체를 만들어낼 수 있습니다.

						자바스크립트에는 private 함수나 변수의 개념이 없다.
						클로저는 자바스크립트를 이용한 고난이도의 테크닉을 구사하는데 필수적인 개념으로 활용된다. -->

						<pre><code class="js">
	var add = function() {
		var counter = 0; //counter는 외부에서 접근할 수 없는 비공개 멤버 (private)

		return function() { //공개 멤버 (반환된 객체를 통해 외부에 공개)
			return ++counter;
		};
	};

	var foo = add(); //인스턴스 foo 생성
	foo(); //1
	foo(); //2

	var bar = add(); //인스턴스 bar 생성 (새롭게 반환되는 인스턴스로 counter 초기화)
	bar(); //1
	bar(); //2
                        </code></pre>
					</section>

					<section>
						<h2>암묵적 전역</h2>
						<ul>
							<li>foo() 함수 내 변수 x에 1을 할당</li>
							<li>foo() 함수 내에는 변수 x가 선언되어 있지 않음</li>
							<li>따라서 상위 지역(전역)에서 변수 x를 찾고 존재하지 않으면</li>
							<li>변수 x를 암묵적으로 전역변수로 선언</li>
						</ul>
						<pre><code class="js">
	function foo() {
		x = 1; //var keyword는 반드시 선언
		var y = 2;
	}
	foo();

	console.log(x); //1
                        </code></pre>
					</section>

					<section>
						<h2>변수명의 중복</h2>
						<p>파일이 분리되어 있어도 글로벌 스코프는 하나,<br>글로벌 스코프에 선언된 변수나 함수는 코드 내의 어디서든지 접근 가능</p>

						<pre class="vertical"><code class="js">
	//x.js
	function foo (){
		// var i = 0;
		i = 0;
	}
                        </code></pre>
                        <pre class="vertical"><code class="js">
	//y.js
	for(var i = 0; i < 5; i++){
		foo();
		console.log(i); //무한 루프 상태
	}
                        </code></pre>

                    	<pre style="margin:0 auto"><code class="html">
    &lt;!DOCTYPE html&gt;
	&lt;html&gt;
	&lt;body&gt;
		&lt;script scr="x.js"&gt;&lt;/script&gt;
		&lt;script scr="y.js"&gt;&lt;/script&gt;
	&lt;/body&gt;
	&lt;/html&gt;
                        </code></pre>
					</section>


					<section>
						<h2>Javascript의 문제점</h2>
						<p>전역변수 사용으로 인해 잠재적인 오류가 발생 할 수 있음</p>

                        <ul>
                            <li>글로벌 스코프가 쉽게 오염</li>
                            <li>동일한 이름을 가진 변수 사용</li>
                            <li>올바른 의존성 순서</li>
                            <li>필요한 코드와 필요하지 않는 코드를 구분하는 것이 매우 어려운 일</li>
                        </ul>


					</section>

<!--
자바스크립트에서 가장 큰 문제점 중의 하나는 파일이 분리되어 있다하여도
글로벌 스코프가 하나이며 글로벌 스코프에 선언된 변수나 함수는 코드 내의 어디서든지 접근이 가능
따라서 다른 스크립트 파일 내에서 동일한 이름으로 명명된 변수나 함수가 같은 스코프 내에 존재할 경우 원치 않는 결과를 가져올 수 있다.
즉시실행함수 내에 처리 로직을 모아 두면 혹시 있을 수도 있는 변수명 또는 함수명의 충돌을 방지할 수 있어 이를 위한 목적으로 즉시실행함수를 사용되기도 한다. -->


					<section>
						<h2>최소한의 전역변수 사용</h2>
						<p>다음과 같이 전역변수 객체 하나를 만들어 사용</p>

<!-- 프로그램의 복잡도가 증가하고 코드의 각 부분들이 별개의 파일로 분리되어 선택적으로 포함하게 되면,
어떤 코드가 특정 네이스페이스나 그 내부의 프로퍼티를 처음으로 정의한다고 가정하기가 위험합니다.
네임스페이스에 추가하려는 프로퍼티가 이미 존재할 수도 있고 따라서 내용을 덮어쓰게 될 지도 모릅니다.
네임스페이스를 생성하거나 프로퍼티를 추가하기 전에 먼저 이미 존재하는지 여부를 확인하는 것이 최선 -->

						<pre><code class="js">
	if(typeof MYAPP === 'undefined') {
		var MYAPP = {};
	}
	//OR
	var MYAPP = MYAPP || {};

	MYAPP.student = {
		name: 'Kim',
		gender: 'male'
	};

	console.log(MYAPP.student.name); //Kim
                        </code></pre>
					</section>


					<section>
						<h2>즉시실행함수 전역변수 사용 억제</h2>
						<ul>
							<li>즉시 실행 함수는 즉시 실행되고 그 후 전역에서 바로 사라짐</li>
							<li>전역변수를 만들지 않으므로 라이브러리 등에 자주 사용</li>
						</ul>

						<pre><code class="js">
	(function() {
		var MYAPP = MYAPP || {};
		MYAPP.student = {
			name: 'Kim',
			gender: 'male'
		};
		console.log(MYAPP.student.name);

		//code...
	}());

	console.log(MYAPP.student.name); //ReferenceError: MYAPP is not defined
                        </code></pre>
					</section>

				</section>



				<section>
					<section>
						<h2>객체지향 프로그래밍 (OOP)</h2>
					</section>

					<section>
						<h2>객체지향 자바스크립트</h2>
						<p>프로토타입 기반(prototype-based) 객체지향 언어</p>
						<p>클래스기반 언어에 익숙한 프로그래머들은 이러한 프로토타입 기반의 특성으로 인해 혼란</p>
						<p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes" target="_blank">ES6 - Classes</a></p>

						<aside class="notes">
자바스크립트 개발을 해본 경험이 있다면 대부분 프로토타입(Prototype)에 대해서 들어봤을 것이다.

프로토타입은 클래스가 없는 자바스크립트에서 객체지향적인 프로그래밍을 하기 위해서 사용하는 특징이라고 할 수 있다.
좀 더 쉽게 말하자면 상속(Inheritance)을 구현하여 객체가 다른 객체에 속성들을 물려줄 수 있도록 하기 위해 프로토타입을 사용


JavaScript는 클래스라는 개념이 없습니다.
그래서 기존의 객체를 복사하여(cloning) 새로운 객체를 생성하는 프로토타입 기반의 언어입니다.

프로토타입 기반 언어는 객체 원형인 프로토타입을 이용하여 새로운 객체를 만들어냅니다.
이렇게 생성된 객체 역시 또 다른 객체의 원형이 될 수 있습니다.
프로토타입은 객체를 확장하고 객체 지향적인 프로그래밍을 할 수 있게 해줍니다.




4. 코드의 재사용
코드의 재사용 하면 떠오르는 단어는 바로 상속입니다.
클래스라는 개념이 있는 Java에서는 중복된 코드를 상속받아 코드 재활용을 할 수 있습니다.
하지만 JavaScript에서는 클래스가 없는, 프로토타입 기반 언어입니다.
 그래서 프로토타입을 이용하여 코드 재사용을 할 수 있습니다.


자바스크립트의 모든 객체는 자신의 부모 역할을 하는 객체와 연결되어 있다.
그리고 이것은 마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메서드를 상속받아 사용할 수 있게 한다. 이러한 부모 객체를 Prototype(프로토타입) 이라 한다.

Javascript에서는  boolean, number, string, 그리고 특별한 값인 null, undefined 빼고는
모두 객체입니다.
사용자가 정의한 함수도 객체이고, new라는 연산자를 통해 생성된 것도 객체입니다.

                        </aside>

					</section>

					<section>
						<pre><code class="js">
	var Person = (function() {
		//생성자 함수 Constructor
		function Person(name) {
			this._name = name;
		}
		//메서드
		//sayHi()함수를 하나만 만들어
		//객체의 인스턴스들이 재사용을 위해서 프로토타입 안에 정의
		Person.prototype.sayHi = function () {
			console.log('Hi! ' + this._name);
		};
		//return constructor
		return Person;
	}());

	var me = new Person('Kim'); //new 연산자를 통해 인스턴스를 me 생성
	me.sayHi(); //메서드 호출 Hi! Kim

	var you = new Person('Lee'); //인스턴스 you 생성
	you.sayHi(); //Hi! Lee
	                    </code></pre>
					</section>

                    <section>
                        <h2>JavaScript 프로토타입 (Prototype)</h2>
                        <p>기본 자료형 (Boolean, null, undefined, Number, String)을 제외한 모든 값은 객체(Object)</p>
                        <p>자바스크립트의 모든 객체는 자신의 부모 역할을 하는 객체와 연결<br>부모 객체의 프로퍼티, 메소드를 상속받아 사용 가능</p>
                        <p>프로토타입은 자신이 다른 객체의 원형이 되는 객체</p>
                    </section>

                    <section>
                        <p>모든 객체의 프로토타입은 객체를 생성할 때 결정</p>
                        <ul>
                            <li>Object.prototype</li>
                            <li>Array.prototype</li>
                            <li>Function.prototype</li>
                        </ul>
                    </section>



                    <section>
                        <h2>Object.prototype</h2>
                        <p>객체 리터럴 방식으로 생성된 객체의 경우 부모는 Object.prototype</p>
                        <p>Object.prototype은 자바스크립트 모든 객체의 최상위 부모</p>
                    </section>


                    <section>
                        <p>student 객체는 __proto__ ( [[Prototype]] )라는 숨겨진 내부 프로퍼티에<br>자신의 부모 객체인 Object.prototype을 연결(Link)</p>
                        <pre><code>
    var student = {
        name: 'Kim',
        score: 90
    };
    console.log(student.valueOf()); //Object {name: "Kim", score: 90}
    //hasOwnProperty(), valueOf(), toString() 등 마치 자신의 프로퍼티인 것처럼 상속받아 사용
                        </code></pre>

                        <img src="img/proto.png" alt="">

                        <aside class="notes">
                        프로토타입은 새로운 객체가 생성되기 위한 원형이 되는 객체.

                        ECMAScript spec에서는 자바스크립트의 모든 객체는 자신의 프로토타입을 가리키는 [[Protytpe]]이라는 숨겨진 내부 프로터피를 가지고 있으며,

                        크롬, 파이어폭스 등에서는 __proto__ 프로퍼티로 구현되어 있습니다.

                        student 객체의 __proto__ 프로퍼티가 가리키는 객체가 바로 Object.prototype 객체이며 hasOwnProperty(), toString(), valueOf() 등과 같은 모든 객체에서 호출 가능한 자바스크립트 기본 내장 메서드가 포함되어 있다.

                        그 결과 student 객체는 student.valueOf(), student.toString()등을 마치 자신의 프로퍼티인 것처럼 상속받아 사용할 수 있다.
                        </aside>
                    </section>


                    <section>
                        <h2>Object.prototype</h2>
                        <img src="img/proto_object.png" alt="" style="width:70%">
                    </section>


                    <section>
                        <h2>Array.prototye</h2>
                        <p>배열의 부모역할을 하는 객체는 Array.prototype</p>
                        <p>모든 배열에 존재하는 length, push(), pop().. 등과 같은 메서드들은<br> Array.prototype 객체의 프로퍼티</p>

                        <pre><code>
    var myArray = [];
    console.log(myArray);
                        </code></pre>

                        <img src="img/proto_array.png" alt="">

                        <aside class="notes">
                        배열도 자바스크립트의 객체다. 자바스크립트의 모든 객체는 자신의 부모역할을 하는 객체와 연결되어 있기 때문에 배열 또한 Array.prototype 객체가 프로토타입이다.
                        </aside>

                    </section>

                    <section>
                        <h2>Array.prototye</h2>
                        <img src="img/proto_object2.png" alt="" style="width:70%">
                    </section>

                    <section>

                        <h2>Function.prototye</h2>
                        <p>함수의 부모 객체는 Function.prototype</p>
                        <pre><code>
    function sum(x, y) {
    	//...
    }
                        </code></pre>

                        <img src="img/proto_function.png" alt="">

                        <aside class="notes">
                        사실 function 함수엔 Prototype 객체를 가르키는 prototype 이란 프로퍼티가 하나 존재합니다.
                        이 Prototype 객체에 공유되어  있는 프로퍼티와 메소드가 객체 생성시 해당 생성자 function 으로
                        생성한 모든 인스턴스에서 공유됩니다.
                        </aside>
                    </section>

                    <section>
                        <h2>Function.prototye</h2>
                        <img src="img/proto_object3.png" alt="" style="width:90%">
                    </section>

				</section>



				<section>
					<section>
						<h2>jQuery</h2>
					</section>

					<section>
						<h2><img src="img/jquery_logo.png" alt="" style="width:40%"></h2>
						<ul>
							<li>자바스크립트의 생산성을 향상시켜주는 자바스크립트 라이브러리</li>
							<li>자바스크립트 코드를 단순하게 유지하면서 크로스 브라우징 이슈를 보다 쉽게 처리</li>
							<li>HTML 문서(DOM) 탐색, 조작, 이벤트 핸들링, 애니메이션, Ajax</li>
						</ul>
					</section>


					<section>
						<h2>jQuery 사용 준비</h2>
						<pre><em class="file_name"><i class="devicons devicons-html5"></i>&nbsp;index.html</em><code class="html">
	&lt;body&gt;
		//...
		&lt;script scr="js/lib/jquery-1.9.1.min.js"&gt;&lt;/script&gt;
		&lt;script scr="js/app.js"&gt;&lt;/script&gt;
	&lt;/body&gt;
                        </code></pre>
                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;app.js</em><code class="js">
	$(document).ready(function(){
		//DOM이 완전히 로드되기 전까지 대기하다가 로드가 완료되면 실행
	});
	//OR
	$(function(){
		// Do something...
	});
                        </code></pre>
					</section>

					<section>
						<h2>셀렉터 (Selector)</h2>
						<ul>
							<li>CSS 스타일의 Selector를 이용하여 요소를 선택</li>
							<li>자바스크립트 DOM API보다 쉽고 강력하며 유연함</li>
						</ul>
					</section>


					<section>
					<p>여러개의 요소 선택, li 요소를 선택하고 이 요소들의 텍스트를 일괄 변경</p>
						<pre><em class="file_name"><i class="devicons devicons-html5"></i>&nbsp;index.html</em><code class="html">
	&lt;ul id="navigation"&gt;
		&lt;li&gt;신세계몰&lt;/li&gt;
		&lt;li&gt;이마트몰&lt;/li&gt;
		&lt;li class="howdy"&gt;하우디&lt;/li&gt;
	&lt;/ul&gt;
                        </code></pre>
                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;app.js</em><code class="js">
	$(function(){
		console.log($('li'));
		// [li, li, li.howdy, prevObject: n.fn.init(1), context: document, selector: "li"]
		$('li').text('SSG');
	});
                        </code></pre>
					</section>

					<section>
						<h2>Pure JavaScript</h2>
		                    <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;app.js</em><code class="js">
	var targets = document.getElementsByTagName('li');

	for(var i = 0; i < targets.length; i++){
		// text노드를 선택한 후, text를 변경
		targets[i].firstChild.nodeValue = 'SSG';
	}
		                    </code></pre>
					</section>


					<section>
						<h2>Tag, ID, Class Selector</h2>
						<p>가능하면 ID selector를 사용<br>document.getElementById()를 사용하기 때문에 ID selector가 빠름</p>
		                    <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;app.js</em><code class="js">
	//Tag Selector
	$('li');

	//ID Selector
	$('#container');

	//Class Selector
	$('.articles');
		                    </code></pre>
					</section>

					<section>
						<h2>자식 선택자 (Child Selector)</h2>
						<ul>
							<li>자신의 1 level 상위에 속하는 요소를 부모 요소</li>
							<li>1 level 하위에 속하는 요소를 자식 요소</li>
						</ul>
						<pre><em class="file_name"><i class="devicons devicons-html5"></i>&nbsp;index.html</em><code class="html">
	&lt;ul id="navigation"&gt;
		&lt;li&gt;신세계몰&lt;/li&gt;
		&lt;li&gt;이마트몰
			&lt;ul id="obanjang"&gt;
				&lt;li&gt;오반장&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
		&lt;li class="howdy"&gt;하우디&lt;/li&gt;
	&lt;/ul&gt;
                        </code></pre>

	                    <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;app.js</em><code class="js">
	$('#navigation > li').text('SSG').css('color', 'red');
	                    </code></pre>
					</section>


					<section>
						<h2>DOM 탐색(Traversing)</h2>
						<p>특정 id를 기준으로 자식 element 목록을 탐색할 때는 .find()를 사용</p>

						<pre><em class="file_name"><i class="devicons devicons-html5"></i>&nbsp;index.html</em><code class="html">
	&lt;ul id="navigation"&gt;
		&lt;li&gt;신세계몰&lt;/li&gt;
		&lt;li&gt;이마트몰&lt;/li&gt;
		&lt;li class="howdy"&gt;하우디&lt;/li&gt;
	&lt;/ul&gt;
                        </code></pre>

	                    <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;app.js</em><code class="js">
	var elem1 = $('#navigation').find('li'); //Traversing
	var elem2 = $('#navigation').find('.howdy');
	                    </code></pre>
					</section>


					<section>
						<h2>DOM 조작(Manipulation)</h2>
						<p>DOM에 새로운 요소를 추가/삭제, 복사, 속성 변경</p>

						<pre><em class="file_name"><i class="devicons devicons-html5"></i>&nbsp;index.html</em><code class="html">
	&lt;div class=&quot;item&quot;&gt;
		&lt;h3 class=&quot;name&quot;&gt;미네랄 워터 생수&lt;/h3&gt;
		&lt;button&gt;가격보기&lt;/button&gt;
	&lt;/div&gt;
                        </code></pre>

	                    <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;app.js</em><code class="js">
	//append() 새로운 요소 추가
	var price = $('&lt;span&gt;할인적용가 2,520&lt;/span&gt;');
	$('.item').append(price);

	//remove() 요소 제거
	$('button').remove();
	                    </code></pre>
					</section>


					<section>
						<p>DOM에 콘텐츠를 삽입할 때, 위치를 지정</p>

						<pre><em class="file_name"><i class="devicons devicons-html5"></i>&nbsp;index.html</em><code class="html">
	[before]
	&lt;div class=&quot;item&quot;&gt;
		[prepend]
		&lt;h3 class=&quot;name&quot;&gt;미네랄 워터 생수&lt;/h3&gt;
		&lt;button&gt;가격보기&lt;/button&gt;
		[append]
	&lt;/div&gt;
	[after]
                        </code></pre>

	                    <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;app.js</em><code class="js">
	$('.item').prepend(price); //선택 요소의 여는 태그 뒤
	$('.item').append(price);  //선택 요소의 닫는 태그 앞
	$('.item').before(price);  //선택 요소의 앞
	$('.item').after(price);   //선택 요소의 뒤
	                    </code></pre>
					</section>


					<section>
						<h2>Event</h2>
						<p>이벤트를 바인딩하고 해당 이벤트가 발생했을 때 실행될 콜백 함수를 지정</p>

						<pre><em class="file_name"><i class="devicons devicons-html5"></i>&nbsp;index.html</em><code class="html">
	&lt;div class=&quot;item&quot;&gt;
		&lt;h3 class=&quot;name&quot;&gt;미네랄 워터 생수&lt;/h3&gt;
		&lt;button&gt;가격보기&lt;/button&gt;
	&lt;/div&gt;
                        </code></pre>

	                    <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;app.js</em><code class="js">
	$('button').on('click', function (e) {
		var price = $('&lt;span&gt;할인적용가 2,520&lt;/span&gt;');
		$('.item').append(price);
		$('button').remove();
	});
	                    </code></pre>
					</section>

					<section>
						<ul>
							<li>버튼 요소가 여러개 있을 경우, 모든 버튼요소 제거, 가격 변경</li>
							<li>이벤트가 발생한 버튼만 제거, 가격이 표시 되도록 수정</li>
						</ul>

	                    <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;app.js</em><code class="js">
	//$(this)는 $(e.target)
	//closest() 메서드는 가장 근접한 상위 요소를 반환

	$('button').on('click', function (e) {
		var price = $('&lt;span&gt;할인적용가 2,520&lt;/span&gt;');
		$(this).closest('.item').append(price);
		$(this).remove();
	});
	                    </code></pre>
					</section>

					<section>
						<h2>jQuery 플러그인 (Plug-in)</h2>
						<p>기존 기능을 확장할 수 있게 도와주는 프로그램<br>자주 사용되는 기능들을 플러그인으로 제작해서 사용</p>

						<h3>어떤 플러그인 사용해야 할까요?</h3>
						<ul>
							<li>오픈소스의 중요 요소들 - 안정성, 충분한 문서 (기능 설명, 사용법 및 데모)</li>
							<li>Github fork 또는 star 수</li>
							<li>적극적인 유지 관리, 브라우저 지원범위</li>
							<li>외부 커뮤니티 (StackOverflow)에 그 플러그인에 대한 질문, 답</li>
						</ul>
					</section>

					<section>
						<h2>bxSlider 플러그인 적용</h2>
						<h3>요구기능</h3>
						<ul>
							<li>좌우버튼 클릭으로 이전, 다음 슬라이드 보기 </li>
							<li>첫번째에서 이전 버튼 클릭 시 '처음 슬라이드 입니다.' 알림메세지 출력 </li>
							<li>마지막에서 다음 버튼 클릭 시 '마지막 슬라이드 입니다.' 알림메세지 출력 </li>
							<li>참고링크 - <a href="https://bxslider.com/examples/" target="_blank">bxSlider</a></li>
						</ul>
	                    <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;app.js</em><code class="js">

	                    </code></pre>
					</section>

				</section>






				<section>
					<div><img src="img/dog.gif" alt=""></div>
					<h1>감사합니다.</h1>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>
		<script>
			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'convex', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

			Reveal.addEventListener( 'slidechanged', function(event) {
				// event.previousSlide, event.currentSlide, event.indexh, event.indexv
				var notes = event.currentSlide.querySelector(".notes");
				if(notes) {
					console.info(notes.innerHTML.replace(/\n\s+/g,'\n'));
				}
			});
		</script>
	</body>
</html>